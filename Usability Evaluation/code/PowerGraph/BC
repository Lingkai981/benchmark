#include <stdlib.h>
#include <math.h>
#include <test.hpp>

class DjikstraNode {
public:
    long id;
    double cost;
    bool launched;
    bool done;

    DjikstraNode(){
        id = 0;
        cost = 1e100;
        launched = false;
        done=false;
    }

  void save(test::oarchive& oarc) const {
    oarc << id << cost << launched << done;
  }

  void load(test::iarchive& iarc) {
    iarc >> id >> cost >> launched >> done;
  }
};

class PrestigeAnalysisNode {
public:
    std::map<long,DjikstraNode> djikstra_pieces;
    double local_value;
    double total;
    long count;
    int edge_count;

    PrestigeAnalysisNode(){
        local_value=0.0;
        total=0.0;
        count=0;
        edge_count=-1;
    }

    void save(test::oarchive& oarc) const {
        oarc << djikstra_pieces << local_value << total << count << edge_count;
    }

    void load(test::iarchive& iarc) {
        iarc >> djikstra_pieces >> local_value >> total >> count >> edge_count;
    }
};

class Gather {
public:
    unsigned long id;
    double cost;
    int edge_count;

    Gather(){
        id=0;
        cost=0.0;
        edge_count=1;
    }

    Gather& operator+=(const Gather& other){
        if(other.id < 0){
            return *this;
        }
        if(this->id < 0){
            return *this;
        }
        if (cost <= other.cost){
            this->edge_count++;
            return *this;
        }
        this->edge_count += other.edge_count;
        return *this;
    }


    void save(test::oarchive& oarc) const {
       oarc << id << cost << edge_count;
     }

     void load(test::iarchive& iarc) {
       iarc >> id >> cost >> edge_count;
     }

};


class GatherMultiTree {
public:
    std::map<long,Gather> content;
    int edge_count;

    GatherMultiTree(){
        edge_count=0;
    }

    GatherMultiTree& operator+=(const GatherMultiTree& other){
        return *this;
    }

    void save(test::oarchive& oarc) const {
        oarc << content << edge_count;
    }

    void load(test::iarchive& iarc) {
        iarc >> content >> edge_count;
    }
};


typedef PrestigeAnalysisNode vertex_data_type;

typedef GatherMultiTree gather_type;

// The graph type is determined by the vertex and edge data types
typedef test::distributed_graph<vertex_data_type, double> graph_type;

bool line_parser(graph_type& graph, const std::string& filename, const std::string& textline) {
  std::stringstream strm(textline);
  test::vertex_id_type vid;
  // first entry in the line is a vertex ID
  strm >> vid;
  PrestigeAnalysisNode node;
  // insert this vertex with its label
  graph.add_vertex(vid, node);
  // while there are elements in the line, continue to read until we fail
  double edge_val=1.0;
  while(1){
    test::vertex_id_type other_vid;
    strm >> other_vid;
    strm >> edge_val;
    if (strm.fail())
      break;
    graph.add_edge(vid, other_vid,edge_val);
  }

  return true;
}

class ClearBooleans :
        public test::ivertex_program<graph_type, gather_type>,
        public test::IS_POD_TYPE {
public:
  edge_dir_type gather_edges(icontext_type& context, const vertex_type& vertex) const {
    return test::NO_EDGES;
  }

  gather_type gather(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
        GatherMultiTree g;
        return g;
  }

  void apply(icontext_type& context, vertex_type& vertex, const gather_type& total) {
      for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
          iter != vertex.data().djikstra_pieces.end(); ++iter){
          long key = iter->first;
          vertex.data().djikstra_pieces[key].launched = false;
          vertex.data().djikstra_pieces[key].done = false;
          vertex.data().djikstra_pieces[key].cost = 0.0;
      }
  }

  edge_dir_type scatter_edges(icontext_type& context, const vertex_type& vertex) const {
          return test::NO_EDGES;
  }

  void scatter(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
  }
};
class DjikstraAlgorithm :
  public test::ivertex_program<graph_type, gather_type>,
  public test::IS_POD_TYPE {
    bool changed;

  public:
    edge_dir_type gather_edges(icontext_type& context, const vertex_type& vertex) const {
      return test::IN_EDGES;
    }

    gather_type gather(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
    Gather g;
    GatherMultiTree tree;
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
            iter != vertex.data().djikstra_pieces.end(); ++iter){
            long key=iter->first;
            if((edge.source().data().djikstra_pieces[key].launched == true)&&
                    (edge.source().data().djikstra_pieces[key].done == false)){
                double c = edge.data() + edge.source().data().djikstra_pieces[key].cost;
                g.cost = c;
                g.id = edge.source().data().djikstra_pieces[key].id;
                g.edge_count = 1;
                tree.content[key] = g;
            }else{
                g.id=0;
            }
        }
    return tree;
    }

    void apply(icontext_type& context, vertex_type& vertex, const gather_type& total) {
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
            iter != vertex.data().djikstra_pieces.end(); ++iter){
            long key = iter->first;
            if(vertex.data().djikstra_pieces[key].launched == false){
                vertex.data().djikstra_pieces[key].launched = true;
                vertex.data().edge_count = total.edge_count;
                    if(vertex.data().djikstra_pieces[key].cost > total.content.find(key)->second.cost){
                    vertex.data().djikstra_pieces[key].cost = total.content.find(key)->second.cost;
                    vertex.data().djikstra_pieces[key].id = total.content.find(key)->second.id;
                    }else{
                    vertex.data().djikstra_pieces[key].done = true;
                    }
            }else{
                vertex.data().djikstra_pieces[key].done = true;
            }
        }
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
            iter != vertex.data().djikstra_pieces.end(); ++iter){
            long key = iter->first;
            if(vertex.data().djikstra_pieces.find(key)==vertex.data().djikstra_pieces.end()){
                vertex.data().djikstra_pieces[key].launched = true;
                vertex.data().edge_count = total.edge_count;
                vertex.data().djikstra_pieces[key].cost = total.content.find(key)->second.cost;
                vertex.data().djikstra_pieces[key].id = total.content.find(key)->second.id;
            }
        }
    }

    edge_dir_type scatter_edges(icontext_type& context, const vertex_type& vertex) const {
      // if vertex data changes, scatter to all edges.
        bool done = true;
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
            iter != vertex.data().djikstra_pieces.end(); ++iter){
            long key = iter->first;
            if(vertex.data().djikstra_pieces.find(key)->second.launched &&
                    !vertex.data().djikstra_pieces.find(key)->second.done){
                done = false;
            }
        }
        if(!done){
            return test::OUT_EDGES;
        }else{
            return test::NO_EDGES;
        }
    }

    void scatter(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
    for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
        iter != vertex.data().djikstra_pieces.end(); ++iter){
        long key = iter->first;
        if((vertex.data().djikstra_pieces.find(key)->second.done == false) &&
                (vertex.data().djikstra_pieces.find(key)->second.launched == true)){
                context.signal(edge.target());
            }
    }
  }
};

size_t num_vertices = 3000;
size_t desired_vertices_count = 3000;
size_t selected_vertices_count = 0;

struct betweeness_writer {
  std::string save_vertex(graph_type::vertex_type v) {
    std::stringstream strm;
    strm << v.id();
    double betweeness = 0.0;
    for(std::map<long, DjikstraNode>::const_iterator iter = v.data().djikstra_pieces.begin();
        iter != v.data().djikstra_pieces.end(); ++iter){
        betweeness += iter->second.cost;
    }
    betweeness /= selected_vertices_count;
    strm << "\t" << betweeness << std::endl;
    return strm.str();
  }
  std::string save_edge (graph_type::edge_type e) { return ""; }
};

bool selectVertices(const graph_type::vertex_type& vertex){
    unsigned int r = random();
    std::cout << "Random seed is " << r << std::endl;
    if(r < (desired_vertices_count * RAND_MAX / num_vertices)){
          selected_vertices_count++;
          return true;
    }
    return false;
}

class BetweenessGather{
public:
    std::map<long,long> counts;
    std::map<long,long> edge_count;

 void save(test::oarchive& oarc) const {
    oarc << counts << edge_count;
  }

  void load(test::iarchive& iarc) {
    iarc >> counts >> edge_count;
  }

  BetweenessGather& operator+=(const BetweenessGather& gather){
    for(std::map<long, long>::const_iterator iter = this->counts.begin();
        iter != this->counts.end(); ++iter ){
                long key = iter->first;
                this->counts[key] += gather.counts.find(key)->second;
                this->edge_count[key] += gather.edge_count.find(key)->second;
	}
    for(std::map<long, long>::const_iterator iter = gather.counts.begin();
            iter != gather.counts.end(); ++iter){
                long key = iter->first;
                if(this->counts.find(key) != this->counts.end()){
                        this->counts[key] = gather.counts.find(key)->second;
                        this->edge_count[key] = gather.edge_count.find(key)->second;
                }
    }
    return *this;
  }


};


class BetweenessAlgorithm :
  public test::ivertex_program<graph_type, BetweenessGather>,
  public test::IS_POD_TYPE {
    bool changed;

  public:
    edge_dir_type gather_edges(icontext_type& context, const vertex_type& vertex) const {
      return test::IN_EDGES;
    }

    BetweenessGather gather(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
	BetweenessGather g;
    for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
        iter != vertex.data().djikstra_pieces.end(); ++iter){
        long key= iter->first;
        if(edge.target().data().djikstra_pieces[key].id == vertex.id()){
            if(edge.source().data().djikstra_pieces[key].launched == true){
                g.counts[key] = edge.source().data().djikstra_pieces[key].cost;
                g.edge_count[key] = 1;
            }
        }
	}
    return g;
    }

    void apply(icontext_type& context, vertex_type& vertex, const BetweenessGather& total) {
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
                iter != vertex.data().djikstra_pieces.end(); ++iter){
            long key = iter->first;
            if(total.edge_count.find(key)->second==0){
                vertex.data().djikstra_pieces[key].launched = true;
                vertex.data().djikstra_pieces[key].cost = 0.0;
            }
            if((vertex.data().djikstra_pieces[key].launched == true)&&
                    (vertex.data().djikstra_pieces[key].done == false)&&
                    (((long)vertex.data().djikstra_pieces[key].cost)==total.edge_count.find(key)->second)){
                vertex.data().djikstra_pieces[key].done = true;
                vertex.data().djikstra_pieces[key].cost = fmax(1.0,(double)total.edge_count.find(key)->second);
            }
        }
    }

    edge_dir_type scatter_edges(icontext_type& context, const vertex_type& vertex) const {
      // if vertex data changes, scatter to all edges.
     	bool done = true;
    for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
        iter != vertex.data().djikstra_pieces.end(); ++iter){
        long key = iter->first;
        if(vertex.data().djikstra_pieces.find(key)->second.launched && !vertex.data().djikstra_pieces.find(key)->second.done){
        		done = false;
      		}
        }
        if(!done){
                return test::OUT_EDGES;
        }else{
                return test::NO_EDGES;
        }
    }

    void scatter(icontext_type& context, const vertex_type& vertex, edge_type& edge) const {
        for(std::map<long, DjikstraNode>::const_iterator iter = vertex.data().djikstra_pieces.begin();
            iter != vertex.data().djikstra_pieces.end(); ++iter){
                long key = iter->first;
                if((vertex.data().djikstra_pieces.find(key)->second.done == false) &&
                        (vertex.data().djikstra_pieces.find(key)->second.launched == true)){
                        context.signal(edge.target());
                }
        }
    }
};

int main (int argc, char** argv){
    // Initialize control plain using mpi
    test::mpi_tools::init(argc, argv);
    test::distributed_control dc;
    global_logger().set_log_level(LOG_INFO);

    // Parse command line options -----------------------------------------------
    test::command_line_options clopts("Betweeness Algorithm.");
    std::string graph_dir;
    clopts.attach_option("graph", graph_dir, "The graph file. Required ");
    clopts.add_positional("graph");
    clopts.attach_option("samplesize", desired_vertices_count, "(Sample Size) Number of spanning trees to use");

    std::string saveprefix;
    clopts.attach_option("saveprefix", saveprefix,
                         "If set, will save the resultant betweness score to a "
                         "sequence of files with prefix saveprefix");

    if(!clopts.parse(argc, argv)) {
      dc.cout() << "Error in parsing command line arguments." << std::endl;
      return EXIT_FAILURE;
    }
    if (graph_dir == "") {
      dc.cout() << "Graph not specified. Cannot continue";
      return EXIT_FAILURE;
    }

    // Build the graph ----------------------------------------------------------
    graph_type graph(dc);
    dc.cout() << "Loading graph using line parser" << std::endl;
    graph.load(graph_dir, line_parser);

    dc.cout() << "#vertices: " << graph.num_vertices() << " #edges:" << graph.num_edges() << std::endl;

    test::omni_engine<DjikstraAlgorithm> engine(dc, graph, "asynchronous", clopts);

    num_vertices = graph.num_vertices();
    test::vertex_set start_set = graph.select(selectVertices);
    engine.signal_vset(start_set);
    engine.start();

    const float runtime = engine.elapsed_seconds();
    dc.cout() << "Finished Djikstra engine in " << runtime << " seconds." << std::endl;

    test::omni_engine<ClearBooleans> engine2(dc,graph,"asynchronous",clopts);
    engine2.signal_all();
    engine2.start();
    const float runtime2 = engine.elapsed_seconds();
    dc.cout() << "Finished resetting graph engine in " << runtime2 << " seconds." << std::endl;

    test::omni_engine<BetweenessAlgorithm> engine3(dc,graph,"asynchronous",clopts);
    engine3.signal_all();
    engine3.start();
    const float runtime3 = engine.elapsed_seconds();
    dc.cout() << "Finished Betweeness engine in " << runtime3 << " seconds." << std::endl;

    if (saveprefix != "") {
      graph.save(saveprefix, betweeness_writer(),
         false,  // do not gzip
         true,   //save vertices
         false); // do not save edges
    }


    test::mpi_tools::finalize();
    return EXIT_SUCCESS;
}


